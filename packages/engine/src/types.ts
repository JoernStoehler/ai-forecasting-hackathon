import type { IconName } from './constants';
import type { GenerateContentConfig, Content } from '@google/genai';

/**
 * Engine event types (hello-world scope):
 * - NewsEvent: primary narrative item generated by the LLM or user.
 * - NewsStoryOpenedEvent: emitted when a user expands a story for the first time.
 *
 * We keep ScenarioEvent as a backwards-compatible alias to NewsEvent for now so
 * the existing webapp/CLI flows keep compiling. IDs and type fields are optional
 * at this milestone; coerceScenarioEvents will backfill reasonable defaults.
 */
export interface NewsEvent {
  type?: 'news'; // defaults to 'news'
  id?: string; // filled in by coercion if missing
  /** ISO date in YYYY-MM-DD */
  date: string;
  /** Lucide icon name (PascalCase) */
  icon: IconName;
  /** Short headline */
  title: string;
  /** Collapsed summary text */
  description: string;
  /** Hidden until a post-mortem phase is toggled */
  postMortem?: boolean;
}

export interface NewsStoryOpenedEvent {
  type: 'story-opened';
  id?: string; // filled in by coercion if missing
  /** ISO date in YYYY-MM-DD */
  date: string;
  /** Reference to the news item that was opened */
  refId: string;
}

export type EngineEvent = NewsEvent | NewsStoryOpenedEvent;

// Back-compat alias used by the current UI & CLI; equals NewsEvent.
export type ScenarioEvent = NewsEvent;

export interface ForecasterContext {
  history: EngineEvent[];
  systemPrompt: string;
}

export interface ForecasterOptions {
  /** Optional temperature or randomness knob; forwarded to model adapters. */
  temperature?: number;
  /** Optional seed for deterministic runs if the backend supports it. */
  seed?: number;
  /** Limit how many events a forecaster should return; enforced by adapter. */
  maxEvents?: number;
}

export interface Forecaster {
  /** Human-readable identifier (for logging, error messages). */
  readonly name: string;
  forecast(context: ForecasterContext, options?: ForecasterOptions): Promise<ScenarioEvent[]>;
}

export interface EngineConfig {
  forecaster: Forecaster;
  systemPrompt?: string;
}

export interface EngineApi {
  forecast(history: ScenarioEvent[], options?: ForecasterOptions): Promise<ScenarioEvent[]>;
  merge(history: ScenarioEvent[], additions: ScenarioEvent[]): ScenarioEvent[];
  nextDate(history: ScenarioEvent[]): string;
  coerce(payload: unknown, source: string): ScenarioEvent[];
}

export interface AggregatedState {
  events: EngineEvent[];
  latestDate: string | null;
  eventCount: number;
}

/**
 * Prepared prompt saved to disk for replay/call steps.
 * OPEN QUESTION (awaiting owner confirmation):
 * - Should `contents` stay stringified JSON (current) or be the SDK `Content[]`
 *   structure to be fully curl-ready without casting?
 * - `config` currently only carries systemInstruction + responseMimeType; add
 *   more fields once the prompt contract is locked.
 */
export interface PreparedPrompt {
  model: string;
  request: {
    model: string;
    contents: Content[]; // sendable as-is to generateContent/Stream
    config: GenerateContentConfig;
  };
  materialsUsed: string[];
}
