#!/usr/bin/env bash

set -euo pipefail

have_cmd() {
  command -v "$1" >/dev/null 2>&1
}

PROJECT_ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
PERSIST_ROOT="$PROJECT_ROOT/.persist"

ensure_tools() {
  if have_cmd rg; then
    echo "[post-create] ripgrep present"
  else
    if have_cmd apt-get; then
      echo "[post-create] installing ripgrep via apt-get (sudo)"
      sudo apt-get update -y
      sudo apt-get install -y ripgrep
    else
      echo "[post-create] ripgrep missing and no apt-get; install manually" >&2
    fi
  fi

  if have_cmd codex; then
    echo "[post-create] codex CLI present"
  else
    if have_cmd npm; then
      echo "[post-create] installing @openai/codex CLI globally"
      npm install -g @openai/codex
    else
      echo "[post-create] npm missing; cannot install codex CLI" >&2
    fi
  fi
}

# Ensure a path is a symlink to a persisted directory inside the workspace.
# Usage: ensure_persist_link <link_path> <persist_dir>
ensure_persist_link() {
  local link_path="$1"
  local persist_dir="$2"

  mkdir -p "$persist_dir"
  mkdir -p "$(dirname "$link_path")"

  if [ -L "$link_path" ]; then
    local current_target
    current_target="$(readlink -f "$link_path" 2>/dev/null || readlink "$link_path" 2>/dev/null || echo)"
    if [ "$current_target" = "$persist_dir" ]; then
      echo "[post-create] already linked: $link_path -> $persist_dir"
      return 0
    else
      echo "[post-create] relinking $link_path to $persist_dir"
      rm -f "$link_path"
    fi
  elif [ -e "$link_path" ]; then
    # Migrate existing content into persist_dir if empty
    if [ -d "$link_path" ] && [ -z "$(ls -A "$persist_dir" 2>/dev/null)" ]; then
      echo "[post-create] migrating existing $(basename "$link_path") to persisted dir"
      shopt -s dotglob nullglob
      mv "$link_path"/* "$persist_dir"/ 2>/dev/null || true
      shopt -u dotglob nullglob
    fi
    rm -rf "$link_path"
  fi

  ln -sfn "$persist_dir" "$link_path"
  echo "[post-create] linked $link_path -> $persist_dir"
}

setup_persistence() {
  mkdir -p "$PERSIST_ROOT"

  local codex_persist="$PERSIST_ROOT/codex"
  local vibe_data_persist="$PERSIST_ROOT/vibe-kanban-data"
  local vibe_worktrees_persist="$PERSIST_ROOT/vibe-kanban-worktrees"

  ensure_persist_link "$HOME/.codex" "$codex_persist"
  ensure_persist_link "$HOME/.local/share/vibe-kanban" "$vibe_data_persist"

  mkdir -p /var/tmp/vibe-kanban
  ensure_persist_link "/var/tmp/vibe-kanban/worktrees" "$vibe_worktrees_persist"
}

sync_env_local_from_env() {
  local env_path="$PROJECT_ROOT/.env.local"
  local gemini_val="${GEMINI_API_KEY:-}"
  local tavily_val="${TAVILY_API_KEY:-}"

  if [ -n "$gemini_val" ] || [ -n "$tavily_val" ]; then
    {
      if [ -n "$gemini_val" ]; then
        printf "GEMINI_API_KEY=%s\n" "$gemini_val"
      fi
      if [ -n "$tavily_val" ]; then
        printf "TAVILY_API_KEY=%s\n" "$tavily_val"
      fi
    } > "$env_path"
    chmod 600 "$env_path" || true
      echo "[post-create] wrote .env.local from available API secrets"
  else
    if [ -f "$env_path" ]; then
      echo "[post-create] API secrets not set; kept existing .env.local"
    else
      printf "GEMINI_API_KEY=PLACEHOLDER\n" > "$env_path"
      chmod 600 "$env_path" || true
      echo "[post-create] API secrets not set; created placeholder .env.local"
    fi
  fi
}

write_persisted_env_exports() {
  local secrets_dir="$PERSIST_ROOT/secrets"
  local secrets_path="$secrets_dir/env.sh"
  local gemini_val="${GEMINI_API_KEY:-}"
  local tavily_val="${TAVILY_API_KEY:-}"

  if [ -z "$gemini_val" ] && [ -z "$tavily_val" ]; then
    if [ -f "$secrets_path" ]; then
      echo "[post-create] API secrets not set; kept existing $secrets_path"
    else
      echo "[post-create] API secrets not set; no persisted exports created"
    fi
    return 0
  fi

  mkdir -p "$secrets_dir"
  {
    echo "#!/usr/bin/env bash"
    echo "# Autogenerated by scripts/post-create.sh"
    if [ -n "$gemini_val" ]; then
      printf "export GEMINI_API_KEY=%q\n" "$gemini_val"
    fi
    if [ -n "$tavily_val" ]; then
      printf "export TAVILY_API_KEY=%q\n" "$tavily_val"
    fi
  } > "$secrets_path"

  chmod 600 "$secrets_path" || true
  echo "[post-create] wrote persisted API exports to $secrets_path"
}

ensure_shell_sources_persisted_env() {
  local rc_file="$1"
  local marker_start="# >>> ai-forecasting-hackathon persisted env >>>"
  local marker_end="# <<< ai-forecasting-hackathon persisted env <<<"

  if [ ! -f "$rc_file" ]; then
    return 0
  fi

  if rg -Fq "$marker_start" "$rc_file" >/dev/null 2>&1; then
    echo "[post-create] $(basename "$rc_file") already sources persisted env"
    return 0
  fi

  {
    printf "\n%s\n" "$marker_start"
    printf 'if [ -f "%s/secrets/env.sh" ]; then\n' "$PERSIST_ROOT"
    printf '  . "%s/secrets/env.sh"\n' "$PERSIST_ROOT"
    printf "fi\n"
    printf "%s\n" "$marker_end"
  } >> "$rc_file"

  echo "[post-create] configured $(basename "$rc_file") to source persisted env"
}

main() {
  ensure_tools
  setup_persistence
  write_persisted_env_exports
  ensure_shell_sources_persisted_env "$HOME/.bashrc"
  ensure_shell_sources_persisted_env "$HOME/.zshrc"
  ensure_shell_sources_persisted_env "$HOME/.profile"
  sync_env_local_from_env
  echo "[post-create] done"
}

main "$@"
